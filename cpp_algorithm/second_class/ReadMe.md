# 第二节课涉及的算法

## Master 公式

### 定义

Master 公式是一种用来分析**分治算法**时间复杂度的通用方法，特别是递归关系的时间复杂度。它适用于以下形式的递归关系：

\[
T(n) = aT\left(\frac{n}{b}\right) + O(n^d)
\]

其中：

- \( T(n) \) 是问题的时间复杂度。
- \( a \) 表示递归调用的次数（子问题的个数）。
- \( b \) 表示每次递归时，问题规模的缩减比例（每次将问题规模除以 \( b \)）。
- \( O(n^d) \) 是问题分解和合并的成本。

### 适用条件

Master 公式适用于**子问题规模相等**的分治算法，比如归并排序、二叉树相关问题。

### 公式的三种情况

根据参数 \( a \)、\( b \)、\( d \) 之间的关系，Master 公式可以分为以下三种情况：

1. **情况 1**：如果 \( a > b^d \)：
   - 时间复杂度：\( T(n) = O(n^{\log_b a}) \)
   - 解释：递归调用的次数主导了整个复杂度，意味着子问题占用更多的时间。

2. **情况 2**：如果 \( a = b^d \)：
   - 时间复杂度：\( T(n) = O(n^d \log n) \)
   - 解释：分解与合并的时间和递归调用的时间是平衡的。

3. **情况 3**：如果 \( a < b^d \)：
   - 时间复杂度：\( T(n) = O(n^d) \)
   - 解释：分解与合并的成本主导了整个复杂度，递归调用的时间相对较少。

#### 例子：二分查找

二分查找的递归关系为：
\[
T(n) = T\left(\frac{n}{2}\right) + O(1)
\]
对于这个例子：

- \( a = 1 \)
- \( b = 2 \)
- \( d = 0 \)

根据 Master 公式的第一种情况，时间复杂度为：
\[
T(n) = O(\log n)
\]

Master 公式为分析分治算法的时间复杂度提供了一种简单有效的工具，能够通过递归关系快速得出算法的复杂度。

## 归并排序

### 定义

归并排序是一种基于**分治思想**的排序算法，将数组分成两部分分别排序，然后将排好序的部分合并。它的主要步骤是递归地将问题分解，直到无法再分解为止，然后在合并过程中完成排序。

### 算法步骤

1. **分割**：
   - 将数组分成两半，递归地对每一半进行排序。

2. **递归排序**：
   - 不断地将数组一分为二，直到每个子数组只有一个元素，此时认为该子数组是有序的。

3. **合并**：
   - 合并两个已经排序的子数组，合并时按从小到大的顺序将元素加入到新的数组中。

### 时间复杂度

归并排序的时间复杂度为 \(O(n \log n)\)，因为每次递归的深度为 \( \log n \)（问题不断对半划分），每一层的合并过程需要遍历整个数组（即 \(O(n)\) 的复杂度）。

- **最坏情况**：\(O(n \log n)\)
- **最好情况**：\(O(n \log n)\)
- **平均情况**：\(O(n \log n)\)

### 空间复杂度

归并排序的空间复杂度为 \(O(n)\)，因为在合并时需要使用额外的空间来存放临时数组。

### 稳定性

归并排序是**稳定排序算法**，即相等元素的相对顺序不会改变。

### 应用场景

归并排序适合处理**大规模数据**或数据规模较大的排序问题，特别是在需要稳定排序的场景中表现优异。

### 例子

假设对数组 `[12, 11, 13, 5, 6, 7]` 进行归并排序，步骤如下：

1. 分割数组成两半：`[12, 11, 13]` 和 `[5, 6, 7]`。
2. 分别对两半进行递归排序：
   - `[12, 11, 13]` 分割为 `[12]` 和 `[11, 13]`，再进一步排序合并为 `[11, 12, 13]`。
   - `[5, 6, 7]` 分割为 `[5]` 和 `[6, 7]`，排序后合并为 `[5, 6, 7]`。
3. 合并两个有序数组，得到最终排序结果 `[5, 6, 7, 11, 12, 13]`。

归并排序通过分治和递归的方式进行排序，时间复杂度为 \(O(n \log n)\)，适合大规模排序，并且是稳定的排序算法。

## 归并排序的拓展问题--小和问题

### 定义

小和问题是一个经典的算法问题，通常在数组中涉及**逆序对**的思路。对于一个数组中的每一个元素，计算这个元素左边所有比它小的元素的和，称之为该元素的小和。整个数组的小和是所有元素的小和的总和。

### 形式化描述

给定一个数组 `arr`，对于每个元素 `arr[i]`，找到其左边所有比 `arr[i]` 小的元素，并将这些元素相加。最后将所有元素的小和相加，得到整个数组的小和。

- **小和**：对于每个 `arr[i]`，它的小和是所有满足 `arr[j] < arr[i]`（其中 `j < i`）的 `arr[j]` 的累加和。

### 例子

假设有数组 `[1, 3, 4, 2, 5]`，计算其小和：

- `1` 的左边没有元素，小和为 0。
- `3` 的左边比 `3` 小的元素是 `1`，小和为 `1`。
- `4` 的左边比 `4` 小的元素是 `1, 3`，小和为 `1 + 3 = 4`。
- `2` 的左边比 `2` 小的元素是 `1`，小和为 `1`。
- `5` 的左边比 `5` 小的元素是 `1, 3, 4, 2`，小和为 `1 + 3 + 4 + 2 = 10`。

因此，整个数组的小和为：`0 + 1 + 4 + 1 + 10 = 16`。

### 解决思路

1. **暴力法**：可以通过两层循环直接计算每个元素的小和，时间复杂度为 O(n²)。外层循环遍历数组的每个元素，内层循环查找当前元素左边比它小的所有元素。

2. **归并排序法**：利用归并排序的分治思想可以将时间复杂度优化到 \(O(n \log n)\)。在归并的过程中，不仅可以完成排序，还可以通过计算合并时的逆序对来快速获得小和。逆序对的思路就是将求该数左边比他小的数的和转换为求每个数比在他右边大的数的个数，最后计算加权和。以`[1, 3, 4, 2, 5]`，并`1`大的数有4个，比`3`大的数有2个，以此类推，最终小和为`1*4 + 3*2 + 4*1 + 2*1 + 5*0 = 16`。
#### 逆序对
逆序对是一个数组中的元素对，满足两个条件：
1. 在数组中，**前面的元素**大于**后面的元素**。
2. 元素的**索引顺序**相反，即较大的元素出现在较小元素的前面。

换句话说，给定一个数组，如果元素 `arr[i] > arr[j]` 且 `i < j`，则称 `(arr[i], arr[j])` 为一个逆序对。

### 应用场景

- 小和问题是**逆序对问题**的变种，常用于考察分治算法和归并排序的应用。
- 它可以用来分析某些排序或数据累加场景下的优化问题。

## 快速排序

### 荷兰国旗问题

荷兰国旗问题是经典的算法问题之一，由计算机科学家 Edsger W. Dijkstra 提出。问题的目标是对数组进行重新排列，使得数组中包含三类元素，并根据某个基准值将这三类元素分开。该问题得名于荷兰国旗的三种颜色（红、白、蓝），对应着数组中三类元素的划分。

#### 问题描述

给定一个数组和一个基准值 `pivot`，将数组分成三个部分：

1. **左侧**部分：所有小于 `pivot` 的元素。
2. **中间**部分：所有等于 `pivot` 的元素。
3. **右侧**部分：所有大于 `pivot` 的元素。

要求在时间复杂度为 O(n) 且空间复杂度为 O(1) 的条件下完成上述分区。

#### 例子

假设有数组 `[2, 0, 2, 1, 1, 0]`，问题要求将数组按基准值 `1` 分区：

- 小于 `1` 的元素（即 `0`）在左边。
- 等于 `1` 的元素在中间。
- 大于 `1` 的元素（即 `2`）在右边。

分区后的数组可能是：`[0, 0, 1, 1, 2, 2]`。

#### 解决思路

解决荷兰国旗问题的常用方法是**双指针**或**三指针**法，能够一次遍历数组，并完成数组的原地分区。具体步骤如下：

1. **设置三个指针**：
   - `low`：指向当前小于 `pivot` 的部分的边界。
   - `high`：指向当前大于 `pivot` 的部分的边界。
   - `current`：遍历整个数组。

2. **遍历数组**：
   - 如果 `arr[current] < pivot`，将其与 `low` 指针交换，`low` 右移，`current` 也右移。
   - 如果 `arr[current] > pivot`，将其与 `high` 指针交换，`high` 左移，而 `current` 保持不动。
   - 如果 `arr[current] == pivot`，只移动 `current`。

3. **结束条件**：当 `current` 超过 `high` 时，分区过程完成。

#### 时间复杂度

- 时间复杂度：O(n)，因为数组只需要遍历一次。
- 空间复杂度：O(1)，无需额外的空间，只使用了常数级别的指针。

### 快速排序算法步骤

1. **选择基准值**：从数组中选择一个元素作为基准值（pivot）。选择策略可以是：
   - 随机选择（3.0版本）。
   - 选择第一个、最后一个或中间的元素。
   
2. **分区**：通过一趟排序将数组分成两个部分：
   - 一部分所有元素小于基准值。
   - 另一部分所有元素大于基准值。
   - 2.0版本就是分成三个部分，小于、等于以及大于部分。
   
3. **递归排序**：对分区后的两部分分别递归地进行快速排序，直到每个部分的元素个数为 1 或 0，表示数组已排好序。

4. **合并**：由于分区的排序是在原地进行的，不需要额外的合并步骤。

### 时间复杂度

- **最坏情况**：O(n²)，当每次分区的基准值选择不当时，比如当数组已经是有序的或逆序的，基准值总是选到最大或最小元素。
  
- **最好情况**：O(n \log n)，当每次分区都能将数组均匀地划分为两部分时。

- **平均情况**：O(n \log n)，这是随机快速排序的期望时间复杂度。

### 空间复杂度

- 快速排序的空间复杂度是 O(log n)（递归调用的栈空间），在最坏情况下，空间复杂度是 O(n)（递归深度达到数组长度）。

### 不稳定性

- 快速排序是**不稳定排序算法**，因为元素的相对顺序可能在分区过程中发生变化。

### 例子

假设对数组 `[3, 6, 8, 10, 1, 2, 1]` 进行快速排序，步骤如下：

1. **选择基准值**：选择最后一个元素 `1` 作为基准值。
2. **分区**：将数组分成两部分：
   - 小于基准值的元素：[1, 1]
   - 大于基准值的元素：[3, 6, 8, 10, 2]
3. **递归排序**：
   - 对 `[1, 1]` 不再需要排序。
   - 对 `[3, 6, 8, 10, 2]` 再次选择基准值并分区，继续递归。

最后，整个数组会排序为 `[1, 1, 2, 3, 6, 8, 10]`。
