# 第一节课涉及的算法

## 时间复杂度

略

## 选择排序

选择排序（Selection Sort）是一种简单直观的排序算法，其基本思想是每次从待排序的序列中找到最小（或最大）的元素，放到已排序序列的末尾，重复此操作直到所有元素都排序完成。

算法的步骤如下：

1. 从未排序部分中找出最小（或最大）的元素；
2. 将该元素与未排序部分的第一个元素交换位置；
3. 重复上述步骤，直到所有元素都被排序。

**特点**：

- 时间复杂度：O(n^2)，因为有两个嵌套的循环。
- 空间复杂度：O(1)，是原地排序，不需要额外的存储空间。
- 稳定性：不稳定，因为在交换时可能会破坏元素的相对顺序。

选择排序适用于元素较少的情况或对性能要求不高的场景。

## 冒泡排序

冒泡排序是一种简单的排序方法，它通过多次遍历数组，比较相邻的两个元素，如果顺序错误就交换它们。这样，较大的元素会逐步“冒泡”到数组的末尾，直到整个数组有序。

步骤：

1. 从头开始，比较相邻的两个元素；
2. 如果前一个比后一个大，交换它们；
3. 重复这个过程，直到最大的元素排到最后；
4. 对剩下的元素重复以上步骤，直到整个数组排序完成。

**特点**：

- 时间复杂度：最坏情况 O(n²)，最好情况 O(n)。
- 空间复杂度：O(1)，原地排序。
- 冒泡排序是**稳定**的，即相等的元素顺序不会改变。

它适合小规模数据排序，简单易懂，但效率不高。

## 两数交换

交换两个数的常见形式有多种，下面列出了几种常见的方式：

**1. 使用临时变量**
这是最常见、最直观的方式，使用一个临时变量来存储其中一个数的值。

```cpp
int temp = a;
a = b;
b = temp;
```

-----
注意，下面的方法要求a和b的地址不是同一个，否则最后a和b都等于0

**2. 不使用临时变量（加减法）**
通过加法和减法交换两个数的值。

``` cpp
a = a + b;  // a 现在是 a + b
b = a - b;  // b 现在是 (a + b) - b = a
a = a - b;  // a 现在是 (a + b) - a = b
```

**3. 不使用临时变量（按位异或 XOR）**
通过 XOR 位运算交换两个数的值。

``` cpp
a = a ^ b;  // a 现在是 a ^ b
b = a ^ b;  // b 现在是 (a ^ b) ^ b = a
a = a ^ b;  // a 现在是 (a ^ b) ^ a = b
```

## 异或操作（同为0，异为1）

1. **自反性**
   - 任意数与自己异或等于 0。
   - 公式：`a ⊕ a = 0`

2. **交换律**
   - 异或操作满足交换律，操作数顺序可以交换。
   - 公式：`a ⊕ b = b ⊕ a`

3. **结合律**
   - 异或操作满足结合律，可以将多个异或运算结合在一起。
   - 公式：`a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c`

4. **与 0 异或**
   - 任意数与 0 异或等于该数本身。
   - 公式：`a ⊕ 0 = a`

5. **消去律**
   - 如果 `a ⊕ b = c`，则 `a = b ⊕ c` 或 `b = a ⊕ c`，可以通过异或反向推导得到其他变量的值。

6. **自反与互异性质**
   - 如果 `a ⊕ b ⊕ b`，可以消去重复的 `b`，结果为 `a`，这表明异或可以用来消去相同的元素。
   - 公式：`a ⊕ b ⊕ b = a`

7. **异或的幂等性**
   - 任意数连续异或偶数次保持不变，奇数次则等于自己。
   - 例如：`a ⊕ a ⊕ a ⊕ a = 0`（偶数次），`a ⊕ a ⊕ a = a`（奇数次）。

8. **异或用于二进制翻转**
   - 异或可以用来翻转二进制的某些位（即对位取反）。
   - 公式：`a ⊕ 1` 将翻转 `a` 中的相应位。

9. **对称性**
   - 任何一个数与异或结果再次异或时，原数恢复：
   - 公式：`a = (a ⊕ b) ⊕ b`

**问题：**

1. 在一个整形数组中，只有一种数出现奇数次，其他的所有数都出现偶数次，怎么找到出现奇数次的数。
**解:** 直接将所有的数异或就行，偶数的数会变成0，奇数的数保留下来
2. 在一个整形数组中，有两种数出现奇数次，其他数都出现偶数次，怎么找到这两个数。
**解：** 假设那两个数为a和b，全部异或后，结果剩下a ^ b。从二进制角度来看，这个结果表示a和b中哪几位是不相同的，而且不同的位为1。将结果的最右边的一个1提取出来，然后让数组中这一位都是1的所有数都异或起来，结果就是a或b中的一个，最后将这个结果与a ^ b异或，得到另一个。

**拓展：**
提取出一个数二进制表示中最右边的 1 的操作 ` x & (~x + 1) ` 或`x & -x`，他们之间是等价的。

## 插入排序

$O(n^2)$中最重要的排序

### 算法步骤

1. **初始状态**：将第一个元素视为已排序。
2. **逐步插入**：从第二个元素开始，依次将每个元素插入到前面已排序的部分。
3. **寻找位置**：对于每一个新元素，从已排序部分的末尾向前扫描，找到合适的位置进行插入。
4. **重复操作**：重复上述步骤，直到所有元素都被插入到正确的位置。

### 特点

- **时间复杂度**：
  - 最坏情况：O(n²)，当数组是逆序排列时。
  - 最好情况：O(n)，当数组已排序时。
  - 平均情况：O(n²)。
  
- **空间复杂度**：O(1)，不需要额外的存储空间。
  
- **稳定性**：插入排序是稳定的，即相等元素的相对顺序不会改变。

### 适用场景

- 适合小规模数据或几乎有序的数据。
- 在数据接近排序完成时，效率较高。

## 二分查找与拓展

1. 在一个有序数组中，找某个数是否存在
   略
2. 在一个有序数组中，找>=某个数最左侧的位置
   略
3. 局部最小值问题
   局部最小值问题是指在给定数组或函数中，找到一个**局部最小值**的位置。局部最小值是指元素值小于或等于其相邻元素的值（在边界处则只需满足一侧的比较）。
   - **局部最小值**：在数组中，元素 `a[i]` 是局部最小值，如果它满足以下条件：
     - 对于内部元素：`a[i-1] ≥ a[i] ≤ a[i+1]`
     - 对于边界元素：`a[0] ≤ a[1]` 或 `a[n-1] ≤ a[n-2]`

## 对数器

测试用的
